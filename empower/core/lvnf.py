#!/usr/bin/env python3
#
# Copyright (c) 2015, Roberto Riggio
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of the CREATE-NET nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY CREATE-NET ''AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL CREATE-NET BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""Light Virtual Network Function."""

import types
import time

import empower.logger
LOG = empower.logger.get_logger()

# add lvnf message sent, no status received
PROCESS_SPAWNING = "spawning"

# add lvnf message sent, status received (process is running)
PROCESS_RUNNING = "running"

# add lvnf message sent, status received (process terminated, check error)
PROCESS_DONE = "done"

# del lvnf message sent, no status received
PROCESS_STOPPING = "stopping"

# del lvnf message sent, status received
PROCESS_STOPPED = "stopped"

# migration (phase 1)
PROCESS_M1 = "m_phase_1"

# migration (phase 2)
PROCESS_M2 = "m_phase_2"

# migration (phase 3)
PROCESS_M3 = "m_phase_3"


def bind_handler(handler):

    def handler_proxy(self, callback=None, every=-1, value=None):

        from empower.handlers.read_handler import read_handler
        from empower.handlers.write_handler import write_handler

        if not value:

            handler = read_handler(lvnf_id=self.lvnf_id,
                                   handler=handler_proxy.handler,
                                   every=every,
                                   callback=callback)

        else:

            handler = write_handler(lvnf_id=self.lvnf_id,
                                    handler=handler_proxy.handler,
                                    every=every,
                                    callback=callback,
                                    value=value)

        return handler

    handler_proxy.handler = handler
    return handler_proxy


class LVNF(object):
    """A Light Virtual Network Function.

    An object representing a Light Virtual Network Function. An LVNF is
    an instance of a Image. Each Image consists of a click script
    implementing the specific VNF. The following boilerplate code is
    automatically generated by the EmPOWER Agent (one port):

        in_0 :: FromHost(vnf-br0-0-0);
        out_0 :: ToHost(vnf-br0-0-0);

    vnf-<bridge>-<k>-<n> is the name of the virtual interface to be created by
    this VNF. <bridge> is the name of the OVS bridge where the VNF is attached,
    <k> is a counter incremented by the agent for each deployed VNF, <n> is
    the virtual port id. Notice how the VNF developer needs not to
    care about the specific value of X and Y, however he/she must use 'in_0'
    and 'out_0' as respectivelly inputs and outputs of his/her VNF. For
    example a valid VNF script for this case is the following:

        in_0 -> null::Null() -> out_0

    After an LVNF is created it is not automatically spawed in a CPP.
    Developers must manually assign the cpp attribute in order to install the
    LVNF in a specific CPP. If the LVNF was previously installed in a CPP,
    then it is first undeployed from the original CPP and then deployed on the
    new CPP. Setting the cpp is asynch, so the fact that the attribute was set
    does not mean that the LVNF was deployed. The developer must either check
    periodically the status of the LVNF or he/she must register a callback
    for the LVNF status event.

    Note, as opposed to LVAPs which can live outside a tenant, an LVNF is
    bound to one and only one tenant. As a result the runtime does not have a
    list of LVNFs which is instead keps by each tenant object.

    Attributes:
        cpp: Pointer to the CPP hosting this LVNF (CPP)
        lvnf_id: The lvnf id (UUID)
        tenant_id: The Tenant id (UUID)
        image: The Image used by this LVNF (Image)
        ports: The virtual ports supported by this LVNF (Map)
        message: The error message retuned by Click (String)
        returncode: The Click process return code, only if stopped (Integer)
        process: The status of the process (running, migrating, migrated,
            stopped, done)
    """

    def __init__(self, lvnf_id, tenant_id, image, cpp=None):

        self.__cpp = cpp
        self.lvnf_id = lvnf_id
        self.tenant_id = tenant_id
        self.image = image
        self.ports = {}
        self.message = None
        self.returncode = None
        self.__process = None
        self.__migration_queue = {}
        self.__migration_target = None
        self.__migration_profiler = 0
        self.last_delta = None

        # bind handlers methods to object instance
        for key in self.image.handlers:
            setattr(self, key, types.MethodType(bind_handler(key), self))

    def __migration_queue_empty(self):
        """Check if all handlers in the migration queue are done."""

        res = [x for x in self.__migration_queue.values() if x.retcode == 200]
        return len(res) == len(self.__migration_queue)

    def start(self):
        """Spawn LVNF."""

        self.__process = PROCESS_SPAWNING

        # send LVNF add message, the actual LVNF will be added upon
        # receiving the lvnf status update message
        self.cpp.connection.send_add_lvnf(self.image,
                                          self.lvnf_id,
                                          self.tenant_id)

    def stop(self):
        """Remove LVNF."""

        self.__process = PROCESS_STOPPING

        # send LVNF del message, the actual LVNF will be removed upon
        # receiving the lvnf status update message
        self.cpp.connection.send_del_lvnf(self.lvnf_id)

    @property
    def cpp(self):
        """Return the CPP."""

        return self.__cpp

    @cpp.setter
    def cpp(self, cpp):
        """Set the CPP."""

        # Process is spawning
        if self.process == PROCESS_SPAWNING:
            raise OSError("LVNF is spawning.")

        # A migration is undergoing, ignore
        if self.process in (PROCESS_M1, PROCESS_M2, PROCESS_M3):
            raise OSError("LVNF migration undergoing.")

        # If cpp is set, and this is not a null assignment then start migration
        if self.cpp and cpp:

            LOG.info("LVNF %s start migration...", self.lvnf_id)

            # Set process status to MIGRATING
            LOG.info("LVNF %s migration: transitioning to state %s.",
                     self.lvnf_id, PROCESS_M1)

            self.process = PROCESS_M1

            # Aet target cpp
            self.__migration_target = cpp
            self.__migration_profiler = time.time()

            if self.cpp == cpp:
                self.__migration_done()
                return

            # Spawn new lvnf
            LOG.info("LVNF %s migration: add %s!" %
                     (self.lvnf_id, self.__migration_target.addr))

            self.__migration_target.\
                connection.send_add_lvnf(self.image,
                                         self.lvnf_id,
                                         self.tenant_id)

            # Read state
            self.__migration_read_state()

            # Done
            return

        # cpp was set, and this is a null assignment: just remove lvnf
        if self.cpp and not cpp:
            self.cpp.connection.send_del_lvnf(self.lvnf_id)
            return

        # cpp was not set, and this is not a null assignment: just add lvnf
        if not self.cpp and cpp:
            cpp.connection.send_add_lvnf(self.image,
                                         self.lvnf_id,
                                         self.tenant_id)

        # cpp was not set, and this is a null assignment: do nothing
        if not self.cpp and not cpp:
            pass

        # set cpp
        self.__cpp = cpp

    @property
    def process(self):
        """Return the process status."""

        return self.__process

    @process.setter
    def process(self, value):
        """Set the process."""

        if self.process == PROCESS_M1:

            # LVNF has been added. If also the migration queue is empty, the
            # start restoring the state, otherwise return. In this case the
            # state restoration will begin when the migration queue is empty.
            if value == PROCESS_RUNNING:

                # setting migrated state
                LOG.info("LVNF %s migration: transitioning to state %s.",
                         self.lvnf_id, PROCESS_M2)

                self.__process = PROCESS_M2

                if self.__migration_queue_empty():

                    # restore state
                    self.__migration_restore_state()

            else:

                LOG.error("%s: got invalid new state: %s" %
                          (self.process, value))

        elif self.process == PROCESS_M2:

            # LVNF has been removed, If also the migration queue is empty,
            # then the migration queue is finished, otherwise return. In this
            # case the migration will be completed when the migration queue is
            # empty.
            if value == PROCESS_STOPPED:

                # setting migrated state
                LOG.info("LVNF %s migration: transitioning to state %s." %
                         (self.lvnf_id, PROCESS_M3))

                self.__process = PROCESS_M3

                if self.__migration_queue_empty():

                    # migration finished
                    self.__migration_done()

            else:

                LOG.error("%s: got invalid new state: %s" %
                          (self.process, value))

        else:

            self.__process = value

    def __migration_done(self):
        """Migration done."""

        # profiling
        self.last_delta = time.time() - self.__migration_profiler

        LOG.info("LVNF %s migration completed, elapsed time %u ms!" %
                 (self.lvnf_id, self.last_delta * 1000))

        # reset migration data structures
        self.__migration_queue = {}
        self.__migration_target = None
        self.__migration_profiler = 0

        # Set process status to RUNNING
        LOG.info("LVNF %s migration: transitioning to state %s." %
                 (self.lvnf_id, PROCESS_RUNNING))

        self.__process = PROCESS_RUNNING

    def __migration_read_state(self):
        """Read this LVNF state."""

        LOG.info("LVNF %s migration: read state." % self.lvnf_id)

        # call state handlers and fill migration queue
        for handler in self.image.state_handlers:

            LOG.info("LVNF %s migration: reading %s" %
                     (self.lvnf_id, handler))

            func = getattr(self, handler)
            module = func(callback=self.__migration_read_callback)

            self.__migration_queue[module.module_id] = module

    def __migration_read_callback(self, handler):
        """Migration callback."""

        LOG.info("LVNF %s migration: got read handler %s" %
                 (self.lvnf_id, handler.handler))

        # If queue is empty and lvnf add returned, then restore state
        if self.__migration_queue_empty() and self.process == PROCESS_M2:

            # Restore state
            self.__migration_restore_state()

    def __migration_restore_state(self):

        partial = time.time() - self.__migration_profiler
        LOG.info("LVNF %s migration: add took %u ms!" %
                 (self.lvnf_id, partial * 1000))

        LOG.info("LVNF %s migration: restoring state." % self.lvnf_id)

        # remove old lvnf
        LOG.info("LVNF %s migration: removing from %s!" %
                 (self.lvnf_id, self.cpp.addr))

        self.cpp.connection.send_del_lvnf(self.lvnf_id)

        # set cpp
        self.__cpp = self.__migration_target

        # setting old state
        for key in self.__migration_queue:

            value = self.__migration_queue[key].samples
            handler = self.__migration_queue[key].handler

            LOG.info("LVNF %s migration: writing %s." %
                     (self.lvnf_id, handler))

            func = getattr(self, handler)
            module = func(value=value,
                          callback=self.__migration_restore_callback)

            self.__migration_queue[key] = module

    def __migration_restore_callback(self, handler):

        LOG.info("LVNF %s migration: got write handler %s %u %s" %
                 (self.lvnf_id, handler.handler, handler.retcode,
                  handler.samples))

        # If queue is empty and lvnf del returned, then we are done
        if self.__migration_queue_empty() and self.process == PROCESS_M3:

            # migration finished
            self.__migration_done()

    def to_dict(self):
        """ Return a JSON-serializable dictionary representing the Poll """

        return {'lvnf_id': self.lvnf_id,
                'image': self.image,
                'tenant_id': self.tenant_id,
                'cpp': self.cpp,
                'process': self.process,
                'message': self.message,
                'returncode': self.returncode,
                'ports': self.ports}

    def __eq__(self, other):
        if isinstance(other, LVNF):
            return self.lvnf_id == other.lvnf_id
        return False

    def __str__(self):
        """ Return a string representation of the LVNF."""

        return "LVNF %s (nb_ports=%u)\n%s" % \
            (self.lvnf_id, self.image.nb_ports, self.image.vnf)
