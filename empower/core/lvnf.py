#!/usr/bin/env python3
#
# Copyright (c) 2016 Roberto Riggio
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied. See the License for the
# specific language governing permissions and limitations
# under the License.

"""Light Virtual Network Function."""

import time

from empower.core.endpoint import Endpoint

import empower.logger

# add lvap message sent, status not received
PROCESS_SPAWNING = "spawning"

# add lvap message sent, status received
PROCESS_RUNNING = "running"

# del lvap message(s) sent, no status(es) received
PROCESS_REMOVING = "removing"

# del lvap message(s) sent, no status(es) received
PROCESS_TERMINATED = "terminated"


class LVNF(Endpoint):
    """A Light Virtual Network Function.

    An object representing a Light Virtual Network Function. An LVNF is
    an instance of a Image. Each Image consists of a click script
    implementing the specific VNF. The following boilerplate code is
    automatically generated by the EmPOWER Agent (one port):

        in_0 :: FromHost(vnf-br0-0-0);
        out_0 :: ToHost(vnf-br0-0-0);

    vnf-<bridge>-<k>-<n> is the name of the virtual interface to be created by
    this VNF. <bridge> is the name of the OVS bridge where the VNF is attached,
    <k> is a counter incremented by the agent for each deployed VNF, <n> is
    the virtual port id. Notice how the VNF developer needs not to
    care about the specific value of X and Y, however he/she must use 'in_0'
    and 'out_0' as respectivelly inputs and outputs of his/her VNF. For
    example a valid VNF script for this case is the following:

        in_0 -> null::Null() -> out_0

    After an LVNF is created it is not automatically spawed in a CPP.
    Developers must manually assign the cpp attribute in order to install the
    LVNF in a specific CPP. If the LVNF was previously installed in a CPP,
    then it is first undeployed from the original CPP and then deployed on the
    new CPP. Setting the cpp is asynch, so the fact that the attribute was set
    does not mean that the LVNF was deployed. The developer must either check
    periodically the status of the LVNF or he/she must register a callback
    for the LVNF status event.

    Note, as opposed to LVAPs which can live outside a tenant, an LVNF is
    bound to one and only one tenant. As a result the runtime does not have a
    list of LVNFs which is instead keps by each tenant object.

    Attributes:
        cpp: Pointer to the CPP hosting this LVNF (CPP)
        lvnf_id: The lvnf id (UUID)
        tenant_id: The Tenant id (UUID)
        image: The Image used by this LVNF (Image)
        message: The error message retuned by Click (String)
        returncode: The Click process return code, only if stopped (Integer)
        process: The status of the process (running, migrating, migrated,
            stopped, done)
    """

    def __init__(self, uuid, tenant, image, state=None):

        super().__init__(uuid, "LVNF (%s) Endpoint" % uuid)

        self.tenant = tenant
        self.image = image
        self._state = state
        self._cpp = None
        self._target_cpp = None
        self._context = None
        self._timer = None
        self.pending = []
        self.log = empower.logger.get_logger()

    def handle_del_lvnf_response(self, xid, context):
        """Received as result of a del lvnf command."""

        if xid not in self.pending:
            self.log.error("Xid %u not in pending list, ignoring", xid)
            return

        if self.state != PROCESS_REMOVING:
            self.log.error("Del lvnf response received in state %s, ignoring",
                           self.state)
            return

        self.pending.remove(xid)

        # all pending processed
        if not self.pending:
            if self.target_cpp:
                self._context = context
                self.state = PROCESS_SPAWNING
            else:
                self.state = PROCESS_TERMINATED

    def handle_add_lvnf_response(self, xid):
        """Received as result of a del lvnf command."""

        if xid not in self.pending:
            self.log.error("Xid %u not in pending list, ignoring", xid)
            return

        if self.state != PROCESS_SPAWNING:
            self.log.error("Add lvnf response received in state %s, ignoring",
                           self.state)
            return

        self.pending.remove(xid)

        # all pending processed
        if not self.pending:
            self.state = PROCESS_RUNNING

    @property
    def state(self):
        """Return the state."""

        return self._state

    @state.setter
    def state(self, state):
        """Set the CPP."""

        self.log.info("LVNF %s transition %s->%s", self.uuid, self.state,
                      state)

        if self.state:
            method = "_%s_%s" % (self.state, state)
        else:
            method = "_none_%s" % state

        if hasattr(self, method):
            callback = getattr(self, method)
            callback()
            return

        raise IOError("Invalid transistion %s -> %s" % (self.state, state))

    def _none_spawning(self):

        # set timer
        self._timer = time.time()

        # set new state
        self._state = PROCESS_SPAWNING

        # Send add lvnf message
        xid = self._target_cpp.connection.send_add_lvnf(self.image,
                                                        self.uuid,
                                                        self.tenant.tenant_id,
                                                        self._context)
        self.pending.append(xid)

        self._context = None

    def _removing_spawning(self):

        # set new state
        self._state = PROCESS_SPAWNING

        # Send add lvnf message
        xid = self._target_cpp.connection.send_add_lvnf(self.image,
                                                        self.uuid,
                                                        self.tenant.tenant_id,
                                                        self._context)

        self.pending.append(xid)

        self._context = None

    def _removing_terminated(self):

        # compute stats
        delta = int((time.time() - self._timer) * 1000)
        self._timer = None
        self.log.info("LVNF %s removal took %sms", self.uuid, delta)

    def _spawning_running(self):

        # set new state
        self._state = PROCESS_RUNNING

        # compute stats
        delta = int((time.time() - self._timer) * 1000)
        self._timer = None
        self.log.info("LVNF %s spawning took %sms", self.uuid, delta)

        # set cpp
        self._cpp = self._target_cpp

        # set datapath
        self.datapath = self._cpp.datapath

        # reset target cCPP
        self._target_cpp = None

    def _running_removing(self):

        # set timer
        self._timer = time.time()

        # set new state
        self._state = PROCESS_REMOVING

        # send del lvnf message
        xid = self.cpp.connection.send_del_lvnf(self.uuid)
        self.pending.append(xid)

        # reset uplink and downlink
        self._cpp = None

    @property
    def target_cpp(self):
        """Return the CPP on which this LVNF must move"""

        return self._target_cpp

    @property
    def cpp(self):
        """Return the CPP on which this LVNF is running"""

        return self._cpp

    @cpp.setter
    def cpp(self, cpp):
        """Assigns LVNF to new CPP."""

        # save target CPP
        self._target_cpp = cpp

        if self.state is None:
            self.state = PROCESS_SPAWNING
        elif self.state == PROCESS_RUNNING:
            self.state = PROCESS_REMOVING
        else:
            IOError("Setting blocks on invalid state: %s" % self.state)

    def to_dict(self):
        """Return a JSON-serializable dictionary representing the Poll."""

        out = super().to_dict()

        out['image'] = self.image
        out['cpp'] = self.cpp
        out['state'] = self.state

        return out

    def __eq__(self, other):

        if isinstance(other, LVNF):
            return self.uuid == other.uuid

        return False

    def __str__(self):

        return "LVNF %s (nb_ports=%u)\n%s" % \
            (self.uuid, self.image.nb_ports, self.image.vnf)
